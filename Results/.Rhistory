while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=0.8
)
start <- start + tot_entry
}
writeLines('\n')
}
# taken fromhttps://elliotnoma.wordpress.com/2015/07/18/how-to-plot-a-table-of-values-in-r/
plot_table <- function(d, marginColor,main="", text.cex=1.0)
{
plot(c(-1,ncol(d)),c(0,nrow(d)+1), type="n", xaxt="n", yaxt="n", xlab="",ylab="",main=main, bty="n")
for (c in 1:ncol(d)) {
rect(c-1, nrow(d), c, nrow(d) + 1, col=marginColor)
text(c-.5,nrow(d) +.5,colnames(d)[c], cex=text.cex)
}
for (r in 1:nrow(d)) {
rect(-1, r-1, 0, r, col=marginColor)
text(-.5, r-.5,rownames(d)[nrow(d) - r + 1], cex=text.cex)
}
for (r in 1:nrow(d))
for (c in 1:ncol(d)) {
rect(c-1, r-1, c, r)
text(c-.5,r-.5,d[nrow(d) - r + 1,c], cex=text.cex)
}
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=0.8
)
start <- start + tot_entry
}
writeLines('\n')
}
# taken fromhttps://elliotnoma.wordpress.com/2015/07/18/how-to-plot-a-table-of-values-in-r/
plot_table <- function(d, marginColor,main="", text.cex=1.0)
{
plot(c(-1,ncol(d)),c(0,nrow(d)+1), type="n", xaxt="n", yaxt="n", xlab="",ylab="",main=main, bty="n")
for (c in 1:ncol(d)) {
#rect(c-1, nrow(d), c, nrow(d) + 1, col=marginColor)
text(c-.5,nrow(d) +.5,colnames(d)[c], cex=text.cex)
}
for (r in 1:nrow(d)) {
#rect(-1, r-1, 0, r, col=marginColor)
text(-.5, r-.5,rownames(d)[nrow(d) - r + 1], cex=text.cex)
}
for (r in 1:nrow(d))
for (c in 1:ncol(d)) {
rect(c-1, r-1, c, r)
text(c-.5,r-.5,d[nrow(d) - r + 1,c], cex=text.cex)
}
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=0.8
)
start <- start + tot_entry
}
writeLines('\n')
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=1
)
start <- start + tot_entry
}
writeLines('\n')
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=5
)
start <- start + tot_entry
}
writeLines('\n')
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=2
)
start <- start + tot_entry
}
writeLines('\n')
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=1
)
start <- start + tot_entry
}
writeLines('\n')
}
# taken fromhttps://elliotnoma.wordpress.com/2015/07/18/how-to-plot-a-table-of-values-in-r/
plot_table <- function(d, marginColor,main="", text.cex=1.0)
{
plot(c(-1,ncol(d)),c(0,nrow(d)+1), type="n", xaxt="n", yaxt="n", xlab="",ylab="",main=main, bty="n")
for (c in 1:ncol(d)) {
#rect(c-1, nrow(d), c, nrow(d) + 1, col=marginColor)
text(c-1,nrow(d) +1,colnames(d)[c], cex=text.cex)
}
for (r in 1:nrow(d)) {
#rect(-1, r-1, 0, r, col=marginColor)
text(-1, r-1,rownames(d)[nrow(d) - r + 1], cex=text.cex)
}
for (r in 1:nrow(d))
for (c in 1:ncol(d)) {
rect(c-1, r-1, c, r)
text(c-1,r-1,d[nrow(d) - r + 1,c], cex=text.cex)
}
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=1
)
start <- start + tot_entry
}
writeLines('\n')
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=2
)
start <- start + tot_entry
}
writeLines('\n')
}
sampling <- function(resultstan, resultjags_d, resultjags_m){
# set up
load(file = here("data","anesthesia.rda"))
# data
N <- nrow(anesthesia) # total number of annotations
K <- 4 # number of annotation categories
I <- 45 # number of items
J <- 5 # number of annotators
ii <- anesthesia$item # item index for annotation n
jj <- anesthesia$rater # annotator for annotation n
y <- anesthesia$rating # annotation for observation n
# parameters
alpha <- rep(3,K)
n <- 8 # pseudocount of hypothetical prior observations
p <- 0.6 # approximate probability of a correct rating
beta <- array((n*(1-p)/(K-1)),c(J,K,K))
beta
for(j in 1:J){
for (k in 1:K){
beta[j,k,k] <- n*p
}
}
# setting
iterations <- 6000
burnin <- floor(iterations/2)
chains <- 3
data_stan <- list(N=N, y=y, K=K, I=I, J=J, ii=ii, jj=jj,beta=beta, alpha=alpha)
data_jags <- list(N=N, y=y, K=K, I=I, J=J, ii=ii, jj=jj)
parameters = c("pi", "theta","z")
# lists for storing ess
ess_stan <- list()
ess_discrete <- list()
ess_marginalised <- list()
# lists for storing model objects
mod_stan <- list()
mod_discrete <- list()
# with stan
# run the model once to compile
model_fit <- stan(file =
here("Models","DawidSkene.stan"),
data = data_stan, iter=iterations, chain=chains,
warmup=burnin)
for(i in 1:NT){
resultstan[1,i]<- system.time(model_fit <- suppressMessages(stan(file =
here("Models","DawidSkene.stan"),
data = data_stan, iter=iterations, chain=chains,
warmup=burnin)))["elapsed"]
ess_stan[[i]] <- summary(model_fit)$summary[,"n_eff"]
resultstan[2,i] <- min(ess_stan[[i]][0:84])
resultstan[3,i] <- resultstan[1,i]/resultstan[2,i]
resultstan[4,i] <- mean(ess_stan[[i]][0:84])
resultstan[5,i] <- resultstan[1,i]/resultstan[4,i]
mod_stan[[i]] <- model_fit
}
# with jags(discrete)
for(i in 1:NT){
resultjags_d[1,i]<- system.time(model.fit <- jags.model(file =                                 here("Models","Dawid-Skene.txt"), data=data_jags, n.chains=chains))["elapsed"]
resultjags_d[2,i] <- system.time(model.samples <-                                    coda.samples(model.fit, parameters,n.iter=iterations))["elapsed"]
ess_discrete[[i]] <- effectiveSize(model.samples)
resultjags_d[3,i] <- min(ess_discrete[[i]][0:84])
resultjags_d[4,i] <- (resultjags_d[1,i]+resultjags_d[2,i])/resultjags_d[3,i]
resultjags_d[5,i] <- mean(ess_discrete[[i]][0:84])
resultjags_d[6,i] <- (resultjags_d[1,i]+resultjags_d[2,i])/resultjags_d[5,i]
mod_discrete[[i]] <- model.samples
}
# with jags(marginalised)
for(i in 1:NT){
resultjags_m[1,i]<- system.time(model.fit <- jags.model(file =                                 here("Models","Dawid-Skene-marginalised.txt"), data=data_jags, n.chains=chains))["elapsed"]
resultjags_m[2,i] <- system.time(model.samples <-                                    coda.samples(model.fit, parameters,n.iter=iterations))["elapsed"]
ess_marginalised[[i]] <- effectiveSize(model.samples)
resultjags_m[3,i] <- min(ess_marginalised[[i]][0:84])
resultjags_m[4,i] <- (resultjags_m[1,i]+resultjags_m[2,i])/resultjags_m[3,i]
resultjags_m[5,i] <- min(ess_marginalised[[i]][0:84])
resultjags_m[6,i] <- (resultjags_m[1,i]+resultjags_m[2,i])/resultjags_m[5,i]
}
return(list(resultstan=resultstan, resultjags_d=resultjags_d,
resultjags_m=resultjags_m, ess_discrete=ess_discrete, ess_stan=ess_stan, mod_stan=mod_stan, mod_discrete=mod_discrete))
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=2
)
start <- start + tot_entry
}
writeLines('\n')
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=1
)
start <- start + tot_entry
}
writeLines('\n')
}
# taken fromhttps://elliotnoma.wordpress.com/2015/07/18/how-to-plot-a-table-of-values-in-r/
plot_table <- function(d, marginColor,main="", text.cex=1.0)
{
plot(c(-1,ncol(d)),c(0,nrow(d)+1), type="n", xaxt="n", yaxt="n", xlab="",ylab="",main=main, bty="n")
for (c in 1:ncol(d)) {
#rect(c-1, nrow(d), c, nrow(d) + 1, col=marginColor)
text(c-.5,nrow(d) +.5,colnames(d)[c], cex=text.cex)
}
for (r in 1:nrow(d)) {
#rect(-1, r-1, 0, r, col=marginColor)
text(-.5, r-.5,rownames(d)[nrow(d) - r + 1], cex=text.cex)
}
for (r in 1:nrow(d))
for (c in 1:ncol(d)) {
rect(c-1, r-1, c, r)
text(c-.5,r-.5,d[nrow(d) - r + 1,c], cex=text.cex)
}
}
for(i in 1:NT){
par(mfrow=c(3,2))
stan <- summary(r1$mod_stan[[i]])
thetas <- stan1$summary[5:84,"mean"]
start <- 1
print(paste("stan trial",i, ":distribution of latent classes"))
while(start < length(thetas)){
tot_entry <- 16
accuracy <- thetas[start:(start+tot_entry-1)]
print(paste("rater",(start-1)/16+1,sep=""))
error_matrix <- matrix(accuracy, nrow = 4, byrow=TRUE)
#print(error_matrix)
plot_table(round(error_matrix,2), "gray",
main= paste("rater",(start-1)/16+1,sep=""),
text.cex=1
)
start <- start + tot_entry
}
writeLines('\n')
}
# loading all dependencies
library("rater")
require(rjags)
require(coda)
require(here)
require(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
load(file = here("data","anesthesia.rda"))
NT <- 5 # number of trials
set.seed(123)
#rater(anesthesia, dawid_skene())
# using the rater package to run stan
data("anesthesia", package = "rater")
# some setup
N <- nrow(anesthesia) # total number of annotations
K <- 4 # number of annotation categories
I <- 45 # number of items
J <- 5 # number of annotators
ii <- anesthesia$item # item index for annotation n
jj <- anesthesia$rater # annotator for annotation n
y <- anesthesia$rating # annotation for observation n
data_jags <- data_stan <- list(N=N, y=y, K=K, I=I, J=J, ii=ii, jj=jj)
iterations <- 6000
burnin <- floor(iterations/2)
chains <- 3
parameters = c("pi", "theta","z")
# run jags and stan and record the quantities of interest
# quantities of interest:
# *time/min ess
# * min ess
# * time
# * Rhat
# the quantities will be stored in a dataframe with the following columns
# * model
# * quantity
# * trial
# * value
result <- data.frame()
# apart from the quantities of interest, create lists
# for model objects
stan_mod_list <- list()
jags_full_mod_list <- list()
jags_marg_mod_list <- list()
for(t in 1:NT){
# stan
# record stan computation time
time <- system.time(model.rater <- rater(anesthesia, dawid_skene()))["elapsed"]
result <- rbind(result, c("stan", "Computation Time", t, time))
# record stan model
model_fit <- get_stanfit(model.rater)
stan_mod_list[[t]] <- model_fit
# record stan min ess(84 is the number of continuous pars)
ess <- min(summary(model_fit)$summary[,"n_eff"][0:84])
result <- rbind(result, c("stan", "Min Effective Sample Size", t, ess))
# record stan timeper min ess
timeperess <-  time/ess
result <- rbind(result, c("stan", "Time per min Effective Sample", t, timeperess))
# record stan rhat
rhat <- max(mcmc_diagnostics(model.rater)[,"Rhat"])
result <- rbind(result, c("stan", "Rhat", t, rhat))
# jags-full
# record jags-full computation time
time <-
system.time(model.fit <- jags.model(file =here("Models","Dawid-Skene.txt"),
data=data_jags, n.chains=chains))["elapsed"]
+ system.time(model.samples <- coda.samples(model.fit, parameters,
n.iter=iterations))["elapsed"]
result <- rbind(result, c("jags-full", "Computation Time", t, time))
# record jags-full model
jags_full_mod_list[[t]] <- model.samples
# record jags-full min ess
ess <- min(effectiveSize(model.samples)[0:84])
result <- rbind(result, c("jags-full", "Min Effective Sample Size", t, ess))
# record jags-full timeper min ess
timeperess <-  time/ess
result <- rbind(result, c("jags-full", "Time per min Effective Sample", t, timeperess))
# record jags-full rhat
disc <- gelman.diag(model.samples, multivariate = FALSE)
rhat <- max(disc$psrf[1:84,"Upper C.I."])
result <- rbind(result, c("jags-full", "Rhat", t, rhat))
# jags-marg
# record jags-marg computation time
time <-
system.time(model.fit <- jags.model(file =here("Models","Dawid-Skene-marginalised.txt"),
data=data_jags, n.chains=chains))["elapsed"]
+ system.time(model.samples <- coda.samples(model.fit, parameters,
n.iter=iterations))["elapsed"]
result <- rbind(result, c("jags-marg", "Computation Time", t, time))
# record jags-marg model
jags_marg_mod_list[[t]] <- model.samples
# record jags-marg min ess
ess <- min(effectiveSize(model.samples)[0:84])
result <- rbind(result, c("jags-marg", "Min Effective Sample Size", t, ess))
# record jags-marg timeper min ess
timeperess <-  time/ess
result <- rbind(result, c("jags-marg", "Time per min Effective Sample", t, timeperess))
# record jags-marg rhat
disc <- gelman.diag(model.samples, multivariate = FALSE)
rhat <- max(disc$psrf[1:84,"Upper C.I."])
result <- rbind(result, c("jags-marg", "Rhat", t, rhat))
}
colnames(result) <- c("model", "quantity", "trial", "value")
# save results
saveRDS(result, file = paste(here("Results"), "/Dawid-Skene-result.rds", sep=""))
library(egg)
library(dplyr)
library(tidyverse)
# helper function for string wrapping
swr <- function(string, nwrap=20) {
paste(strwrap(string, width=nwrap), collapse="\n")
}
swr <- Vectorize(swr)
result <- readRDS(here("Results","Dawid-Skene-result.rds"))
result$model <- factor(result$model, levels = c("stan", "jags-full", "jags-marg"))
result$quantity <- swr(result$quantity)
result$quantity <- factor(result$quantity, levels = c(swr("Time per min Effective Sample"), "Computation Time",swr( "Min Effective Sample Size"), "Rhat"))
result$trial <- factor(result$trial)
result$value <- as.numeric(result$value)
result
plot1 <- ggplot(subset(result, quantity != "Rhat"), aes(x=model, y=value, group=model)) +  geom_boxplot() + facet_grid(quantity ~., scales='free') + theme_bw() + theme(text = element_text(size=20))#+ scale_fill_brewer(palette = "Set3")
plot2 <- ggplot(subset(result, quantity == "Rhat"), aes(x=model, y=value, group=model)) +  geom_point() + theme_bw() + facet_grid(quantity ~., scales='free') + theme(text = element_text(size=20))+geom_hline(yintercept = 1.1)#+ scale_color_brewer(palette="Set3") +geom_hline(yintercept = 1.1)
#pdf("Dawid-Skene-anesthesia-result.pdf", width = 8, height = 12)
grid.arrange(plot1, plot2, ncol=1 , layout_matrix = cbind(c(1,1,1,2)))
#dev.off()
#pdf("Dawid-Skene-anesthesia-result.pdf", width = 8, height = 12)
grid.arrange(plot1, plot2, ncol=1 , layout_matrix = cbind(c(1,1,1,2)))
#dev.off()
